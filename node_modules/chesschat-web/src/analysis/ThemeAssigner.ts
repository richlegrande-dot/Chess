/**\n * Theme Assigner - Assigns coaching themes to turning points\n * \n * This module takes turning points from engine analysis and assigns\n * appropriate coaching themes based on position characteristics,\n * move quality, and game phase. It forms the bridge between raw\n * analysis data and structured coaching advice.\n */\n\nimport { Chess } from 'chess.js';\nimport { \n  TurnPoint, \n  ThemedTurnPoint, \n  GamePhase, \n  MoveClassification,\n  CoachTheme \n} from './types';\nimport { COACH_THEMES } from './coachThemes';\nimport { PhaseClassifier } from './PhaseClassifier';\n\n/**\n * Configuration for theme assignment\n */\nexport interface ThemeAssignerConfig {\n  maxThemesPerTurnPoint: number;  // Max themes to assign per position\n  priorityThreshold: number;       // Minimum priority for theme assignment\n  phaseWeighting: number;         // How much to weight phase-specific themes\n  skillLevelWeighting: number;    // How much to weight skill-appropriate themes\n}\n\nexport const DEFAULT_THEME_CONFIG: ThemeAssignerConfig = {\n  maxThemesPerTurnPoint: 3,\n  priorityThreshold: 0.6,\n  phaseWeighting: 1.5,\n  skillLevelWeighting: 1.2\n};\n\n/**\n * Assigns coaching themes to turning points\n */\nexport class ThemeAssigner {\n  private config: ThemeAssignerConfig;\n  private phaseClassifier: PhaseClassifier;\n\n  constructor(\n    config: Partial<ThemeAssignerConfig> = {},\n    phaseClassifier?: PhaseClassifier\n  ) {\n    this.config = { ...DEFAULT_THEME_CONFIG, ...config };\n    this.phaseClassifier = phaseClassifier || new PhaseClassifier();\n  }\n\n  /**\n   * Assign themes to a collection of turn points\n   */\n  async assignThemes(\n    turnPoints: TurnPoint[],\n    skillLevel: 'beginner' | 'intermediate' | 'advanced' = 'intermediate'\n  ): Promise<ThemedTurnPoint[]> {\n    const themedTurnPoints: ThemedTurnPoint[] = [];\n\n    for (const turnPoint of turnPoints) {\n      const themes = await this.assignThemesToTurnPoint(turnPoint, skillLevel);\n      \n      themedTurnPoints.push({\n        ...turnPoint,\n        themes,\n        gamePhase: this.phaseClassifier.classifyPhase(\n          turnPoint.fenBefore, \n          turnPoint.moveNumber\n        )\n      });\n    }\n\n    return themedTurnPoints;\n  }\n\n  /**\n   * Assign themes to a single turning point\n   */\n  private async assignThemesToTurnPoint(\n    turnPoint: TurnPoint,\n    skillLevel: 'beginner' | 'intermediate' | 'advanced'\n  ): Promise<CoachTheme[]> {\n    const chess = new Chess(turnPoint.fenBefore);\n    const gamePhase = this.phaseClassifier.classifyPhase(\n      turnPoint.fenBefore, \n      turnPoint.moveNumber\n    );\n    \n    const candidateThemes: Array<{ theme: CoachTheme; score: number }> = [];\n\n    // Evaluate each theme for relevance\n    for (const theme of Object.values(COACH_THEMES)) {\n      const score = this.calculateThemeRelevance(\n        theme,\n        turnPoint,\n        gamePhase,\n        chess,\n        skillLevel\n      );\n      \n      if (score >= this.config.priorityThreshold) {\n        candidateThemes.push({ theme, score });\n      }\n    }\n\n    // Sort by relevance score and return top themes\n    return candidateThemes\n      .sort((a, b) => b.score - a.score)\n      .slice(0, this.config.maxThemesPerTurnPoint)\n      .map(item => item.theme);\n  }\n\n  /**\n   * Calculate how relevant a theme is to a specific turning point\n   */\n  private calculateThemeRelevance(\n    theme: CoachTheme,\n    turnPoint: TurnPoint,\n    gamePhase: GamePhase,\n    chess: Chess,\n    skillLevel: 'beginner' | 'intermediate' | 'advanced'\n  ): number {\n    let score = theme.priority;\n\n    // Phase-specific weighting\n    if (theme.gamePhases.includes(gamePhase)) {\n      score *= this.config.phaseWeighting;\n    }\n\n    // Skill level weighting\n    if (theme.skillLevels.includes(skillLevel)) {\n      score *= this.config.skillLevelWeighting;\n    }\n\n    // Move quality specific themes\n    const moveClassification = this.classifyMoveFromEvalDelta(turnPoint.evalDelta);\n    score *= this.getMoveQualityWeight(theme, moveClassification);\n\n    // Position-specific detection\n    score *= this.getPositionSpecificWeight(theme, turnPoint, chess);\n\n    return Math.min(1.0, score);\n  }\n\n  /**\n   * Get weight based on move quality\n   */\n  private getMoveQualityWeight(\n    theme: CoachTheme,\n    moveClassification: MoveClassification\n  ): number {\n    // Theme-specific move quality preferences\n    const moveQualityWeights: Record<string, Record<MoveClassification, number>> = {\n      'blunder_recovery': {\n        'blunder': 2.0,\n        'mistake': 1.5,\n        'inaccuracy': 1.0,\n        'good': 0.3,\n        'excellent': 0.1\n      },\n      'calculation_accuracy': {\n        'blunder': 2.0,\n        'mistake': 1.8,\n        'inaccuracy': 1.3,\n        'good': 0.8,\n        'excellent': 0.5\n      },\n      'pattern_recognition': {\n        'blunder': 1.8,\n        'mistake': 1.5,\n        'inaccuracy': 1.2,\n        'good': 0.9,\n        'excellent': 0.7\n      }\n    };\n\n    return moveQualityWeights[theme.id]?.[moveClassification] || 1.0;\n  }\n\n  /**\n   * Get weight based on position-specific characteristics\n   */\n  private getPositionSpecificWeight(\n    theme: CoachTheme,\n    turnPoint: TurnPoint,\n    chess: Chess\n  ): number {\n    let weight = 1.0;\n\n    // Category-specific position analysis\n    switch (theme.category) {\n      case 'tactics':\n        weight *= this.getTacticalWeight(chess, turnPoint);\n        break;\n      case 'strategy':\n        weight *= this.getStrategicWeight(chess);\n        break;\n      case 'opening':\n        weight *= this.getOpeningWeight(chess, turnPoint.moveNumber);\n        break;\n      case 'endgame':\n        weight *= this.getEndgameWeight(chess);\n        break;\n      case 'time_management':\n        weight *= this.getTimeManagementWeight(turnPoint);\n        break;\n      case 'psychology':\n        weight *= this.getPsychologyWeight(turnPoint);\n        break;\n    }\n\n    return weight;\n  }\n\n  /**\n   * Calculate tactical position weight\n   */\n  private getTacticalWeight(chess: Chess, turnPoint: TurnPoint): number {\n    let weight = 1.0;\n\n    // Check for tactical motifs\n    if (this.hasTacticalMotifs(chess)) {\n      weight *= 1.5;\n    }\n\n    // Large evaluation swing suggests tactics\n    if (Math.abs(turnPoint.evalDelta) > 200) {\n      weight *= 1.3;\n    }\n\n    return weight;\n  }\n\n  /**\n   * Calculate strategic position weight\n   */\n  private getStrategicWeight(chess: Chess): number {\n    let weight = 1.0;\n\n    // Closed positions favor strategic themes\n    const mobilityScore = chess.moves().length;\n    if (mobilityScore < 30) {\n      weight *= 1.4; // Closed position\n    }\n\n    return weight;\n  }\n\n  /**\n   * Calculate opening-specific weight\n   */\n  private getOpeningWeight(chess: Chess, moveNumber: number): number {\n    if (moveNumber > 15) return 0.3; // Late for opening themes\n    if (moveNumber <= 10) return 1.5; // Perfect for opening themes\n    return 1.0;\n  }\n\n  /**\n   * Calculate endgame-specific weight\n   */\n  private getEndgameWeight(chess: Chess): number {\n    const materialCount = this.calculateMaterialCount(chess);\n    const totalMaterial = materialCount.white + materialCount.black;\n    \n    if (totalMaterial <= 12) return 1.8; // Clear endgame\n    if (totalMaterial <= 20) return 1.3; // Transitioning to endgame\n    return 0.4; // Too much material for endgame themes\n  }\n\n  /**\n   * Calculate time management weight\n   */\n  private getTimeManagementWeight(turnPoint: TurnPoint): number {\n    // Time management themes are more relevant for significant moves\n    const evalMagnitude = Math.abs(turnPoint.evalDelta);\n    return evalMagnitude > 100 ? 1.3 : 1.0;\n  }\n\n  /**\n   * Calculate psychology weight\n   */\n  private getPsychologyWeight(turnPoint: TurnPoint): number {\n    // Psychology themes are relevant for all significant turning points\n    return Math.abs(turnPoint.evalDelta) > 150 ? 1.2 : 1.0;\n  }\n\n  /**\n   * Check for tactical motifs in position\n   */\n  private hasTacticalMotifs(chess: Chess): boolean {\n    // Simple heuristic: check for pieces that can capture each other\n    const moves = chess.moves({ verbose: true });\n    \n    // Check for captures\n    const captures = moves.filter(move => move.captured);\n    if (captures.length > 2) return true;\n\n    // Check for checks\n    const checks = moves.filter(move => move.san.includes('+'));\n    if (checks.length > 0) return true;\n\n    return false;\n  }\n\n  /**\n   * Classify move based on evaluation delta\n   */\n  private classifyMoveFromEvalDelta(evalDelta: number): MoveClassification {\n    const abs = Math.abs(evalDelta);\n    \n    if (abs >= 300) return 'blunder';\n    if (abs >= 150) return 'mistake';\n    if (abs >= 75) return 'inaccuracy';\n    if (abs <= 25) return 'excellent';\n    return 'good';\n  }\n\n  /**\n   * Calculate material count\n   */\n  private calculateMaterialCount(chess: Chess): { white: number; black: number } {\n    const board = chess.board();\n    const pieceValues = {\n      'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9, 'k': 0\n    };\n    \n    let white = 0, black = 0;\n    \n    board.forEach(row => {\n      row.forEach(square => {\n        if (square) {\n          const value = pieceValues[square.type as keyof typeof pieceValues];\n          if (square.color === 'w') white += value;\n          else black += value;\n        }\n      });\n    });\n    \n    return { white, black };\n  }\n\n  /**\n   * Get configuration\n   */\n  getConfig(): ThemeAssignerConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(newConfig: Partial<ThemeAssignerConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n  }\n\n  /**\n   * Get phase classifier instance\n   */\n  getPhaseClassifier(): PhaseClassifier {\n    return this.phaseClassifier;\n  }\n}"