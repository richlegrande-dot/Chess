/**
 * Engine Analyzer - Core engine evaluation and turning point detection
 * 
 * This module handles the heavy lifting of chess position evaluation,
 * identifying critical moments in games where significant evaluation
 * changes occur (turning points) that can be used for coaching.
 */

import { Chess } from 'chess.js';
import { TurnPoint, EvaluatedMove, MoveClassification, MaterialCount } from './types';

/**
 * Configuration for engine analysis
 */
export interface EngineAnalysisConfig {
  depthLimit: number;        // Engine search depth (higher = more accurate, slower)
  timePerMove: number;       // Time limit per position in milliseconds
  blunderThreshold: number;  // Eval delta for blunders (in centipawns)
  mistakeThreshold: number;  // Eval delta for mistakes (in centipawns)
  inaccuracyThreshold: number; // Eval delta for inaccuracies (in centipawns)
  maxTurnPoints: number;     // Maximum turning points to return
}

export const DEFAULT_ENGINE_CONFIG: EngineAnalysisConfig = {
  depthLimit: 12,
  timePerMove: 1000,
  blunderThreshold: 300,    // 3.0 pawns
  mistakeThreshold: 150,    // 1.5 pawns
  inaccuracyThreshold: 75,  // 0.75 pawns
  maxTurnPoints: 10
};\n\n/**\n * Mock engine evaluation for development/testing\n * In production, this would interface with actual Stockfish engine\n */\nexport class MockEngine {\n  private evaluationCache = new Map<string, number>();\n\n  /**\n   * Evaluate position from FEN string\n   * Returns evaluation in centipawns from white's perspective\n   */\n  async evaluatePosition(fen: string): Promise<number> {\n    // Check cache first\n    if (this.evaluationCache.has(fen)) {\n      return this.evaluationCache.get(fen)!;\n    }\n\n    // Mock evaluation based on material count and simple positional factors\n    const chess = new Chess(fen);\n    let evaluation = this.calculateMaterialBalance(chess);\n    \n    // Add positional adjustments\n    evaluation += this.calculatePositionalFactors(chess);\n    \n    // Add some randomness to simulate engine uncertainty\n    evaluation += (Math.random() - 0.5) * 50;\n    \n    // Cache result\n    this.evaluationCache.set(fen, evaluation);\n    return evaluation;\n  }\n\n  /**\n   * Get best move from position\n   * In production, this would query actual engine\n   */\n  async getBestMove(fen: string): Promise<string> {\n    const chess = new Chess(fen);\n    const moves = chess.moves();\n    \n    if (moves.length === 0) return '';\n    \n    // Simple heuristic: prefer captures, checks, then center moves\n    let bestMove = moves[0];\n    let bestScore = -Infinity;\n    \n    for (const move of moves) {\n      let score = Math.random() * 100; // Base randomness\n      \n      // Prefer captures\n      if (move.includes('x')) score += 50;\n      \n      // Prefer checks\n      if (move.includes('+')) score += 30;\n      \n      // Prefer central squares\n      if (['e4', 'e5', 'd4', 'd5'].some(sq => move.includes(sq))) {\n        score += 20;\n      }\n      \n      if (score > bestScore) {\n        bestScore = score;\n        bestMove = move;\n      }\n    }\n    \n    return bestMove;\n  }\n\n  private calculateMaterialBalance(chess: Chess): number {\n    const board = chess.board();\n    let whiteValue = 0;\n    let blackValue = 0;\n    \n    const pieceValues = {\n      'p': 100, 'n': 300, 'b': 300, 'r': 500, 'q': 900, 'k': 0\n    };\n    \n    board.forEach(row => {\n      row.forEach(square => {\n        if (square) {\n          const value = pieceValues[square.type as keyof typeof pieceValues];\n          if (square.color === 'w') {\n            whiteValue += value;\n          } else {\n            blackValue += value;\n          }\n        }\n      });\n    });\n    \n    return whiteValue - blackValue;\n  }\n\n  private calculatePositionalFactors(chess: Chess): number {\n    let score = 0;\n    \n    // King safety bonus/penalty\n    const whiteKing = this.findKing(chess, 'w');\n    const blackKing = this.findKing(chess, 'b');\n    \n    if (whiteKing && blackKing) {\n      // Penalize kings in center during opening/middlegame\n      if (chess.moveNumber() < 15) {\n        if (['e1', 'e8'].includes(whiteKing)) score -= 20;\n        if (['e1', 'e8'].includes(blackKing)) score += 20;\n      }\n    }\n    \n    // Development bonus (simplified)\n    const whitePieces = this.countDevelopedPieces(chess, 'w');\n    const blackPieces = this.countDevelopedPieces(chess, 'b');\n    score += (whitePieces - blackPieces) * 10;\n    \n    return score;\n  }\n\n  private findKing(chess: Chess, color: 'w' | 'b'): string | null {\n    const board = chess.board();\n    for (let i = 0; i < 8; i++) {\n      for (let j = 0; j < 8; j++) {\n        const piece = board[i][j];\n        if (piece && piece.type === 'k' && piece.color === color) {\n          return String.fromCharCode(97 + j) + (8 - i);\n        }\n      }\n    }\n    return null;\n  }\n\n  private countDevelopedPieces(chess: Chess, color: 'w' | 'b'): number {\n    const board = chess.board();\n    let developed = 0;\n    \n    const startRank = color === 'w' ? 7 : 0;\n    \n    for (let i = 0; i < 8; i++) {\n      for (let j = 0; j < 8; j++) {\n        const piece = board[i][j];\n        if (piece && piece.color === color && \n            ['n', 'b', 'q'].includes(piece.type) && \n            i !== startRank) {\n          developed++;\n        }\n      }\n    }\n    \n    return developed;\n  }\n}\n\n/**\n * Main engine analyzer class\n */\nexport class EngineAnalyzer {\n  private engine: MockEngine;\n  private config: EngineAnalysisConfig;\n\n  constructor(config: Partial<EngineAnalysisConfig> = {}) {\n    this.engine = new MockEngine();\n    this.config = { ...DEFAULT_ENGINE_CONFIG, ...config };\n  }\n\n  /**\n   * Analyze complete game from PGN and identify turning points\n   */\n  async analyzeGame(\n    pgn: string, \n    playerColor: 'white' | 'black' = 'white'\n  ): Promise<TurnPoint[]> {\n    const chess = new Chess();\n    \n    try {\n      chess.loadPgn(pgn);\n    } catch (error) {\n      throw new Error(`Invalid PGN: ${error}`);\n    }\n\n    const history = chess.history({ verbose: true });\n    const turnPoints: TurnPoint[] = [];\n    \n    // Reset to start position for analysis\n    chess.reset();\n    \n    let previousEval = await this.engine.evaluatePosition(chess.fen());\n    \n    for (let i = 0; i < history.length; i++) {\n      const move = history[i];\n      const fenBefore = chess.fen();\n      \n      // Get best move before playing the actual move\n      const bestMove = await this.engine.getBestMove(fenBefore);\n      \n      // Play the actual move\n      chess.move(move.san);\n      const fenAfter = chess.fen();\n      \n      // Evaluate after the move\n      const currentEval = await this.engine.evaluatePosition(fenAfter);\n      \n      // Adjust evaluation perspective for black moves\n      const adjustedPrevEval = move.color === 'b' ? -previousEval : previousEval;\n      const adjustedCurrentEval = move.color === 'b' ? -currentEval : currentEval;\n      \n      const evalDelta = adjustedPrevEval - adjustedCurrentEval;\n      \n      // Check if this is a significant turning point\n      if (Math.abs(evalDelta) >= this.config.inaccuracyThreshold) {\n        turnPoints.push({\n          moveNumber: Math.ceil((i + 1) / 2),\n          fenBefore,\n          playedMoveSAN: move.san,\n          bestMoveSAN: bestMove,\n          evalBefore: adjustedPrevEval,\n          evalAfter: adjustedCurrentEval,\n          evalDelta,\n          sideToMove: move.color === 'w' ? 'white' : 'black'\n        });\n      }\n      \n      previousEval = currentEval;\n    }\n    \n    // Sort by evaluation delta magnitude and return top turning points\n    return turnPoints\n      .sort((a, b) => Math.abs(b.evalDelta) - Math.abs(a.evalDelta))\n      .slice(0, this.config.maxTurnPoints);\n  }\n\n  /**\n   * Classify move quality based on evaluation delta\n   */\n  classifyMove(evalDelta: number): MoveClassification {\n    const absAlphabeta = Math.abs(evalDelta);\n    \n    if (absAlphabeta >= this.config.blunderThreshold) return 'blunder';\n    if (absAlphabeta >= this.config.mistakeThreshold) return 'mistake';\n    if (absAlphabeta >= this.config.inaccuracyThreshold) return 'inaccuracy';\n    if (absAlphabeta <= 25) return 'excellent';\n    return 'good';\n  }\n\n  /**\n   * Calculate material count for both sides\n   */\n  calculateMaterialCount(fen: string): MaterialCount {\n    const chess = new Chess(fen);\n    const board = chess.board();\n    \n    const pieceValues = {\n      'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9, 'k': 0\n    };\n    \n    let white = 0, black = 0;\n    \n    board.forEach(row => {\n      row.forEach(square => {\n        if (square) {\n          const value = pieceValues[square.type as keyof typeof pieceValues];\n          if (square.color === 'w') white += value;\n          else black += value;\n        }\n      });\n    });\n    \n    return { white, black };\n  }\n\n  /**\n   * Get engine configuration\n   */\n  getConfig(): EngineAnalysisConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Update engine configuration\n   */\n  updateConfig(newConfig: Partial<EngineAnalysisConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n  }\n}"